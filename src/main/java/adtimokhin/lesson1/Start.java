package adtimokhin.lesson1;

public class Start {
    public static void main(String[] args) {
        method1(2, 4);
        method2(2, 1, 3, 4, 5, 0, -1);
        method3(1, 2, 3, 4, 5, 6, 7, 8, 9, 0, -2);
    }

    private static int method1(int number, int power) {
        for (int i = 0; i < power; i++) {
            number *= number;    // дествие повторяется n раз. Эта операция сложностью в O(n).
        }
        return number;// по сути, return это уже действие k, но для подсчета числа, эта операция не нужна.
        // И поэтому вмсетсо O(n+k), сложность составляет: O(n)
    }

    private static int method2(int... arr) {
        int smallest = arr[0];// Это действие длинной в O(k), но оно не так важно, как нахождение наименьшего числа.
        // Пользуясь данной логикой, я решаю, что этим действием можно пренебречь для посчета О Большого.
        for (int i = 0; i < arr.length; i++) { // Этот цикл по сути и есть наше основное действие длинной в O(n) шагов.
            if (smallest > arr[i])// <- Пользуясь 5-ым правилом, мы можем пренебречь этим множителем, т.к. каждую
                // итерацию цикла мы с ним сталкиваемся.
                smallest = arr[i];//<- Данный же множитель мы не можем игнорироать, потому что не факт, что в каждой
                // итерации цикла мы с ним столкнемся. Пользуясь 4-ым правилом, мы говорим, что каждый шаг O(n),
                // мы сталкиваемся с действием длинной в O(k). И поэтому сложность данного алгоритма равна : O(n*k)
        }
        return smallest; // по анологии с 1-ым методом, данное действие не учитывается.
    }
    private static float method3(int... arr) {
        int i = 0;// Этой операцией можно пренебречь, а в конце вместо i, можно было использовать arr.length.
        float sum = 0; // Этой операцией мы могли пренебречь для подсчета сред. ариф.
        // Опреации наверху, по сути состовляют O(k), но ими мы можем пренебречь, т.к. они не так важны, как наша задача : подсчет сред. ариф.
        for (; i < arr.length; i++) {// Это наше основное действие в O(n) шагов
            sum += arr[i]; // этим постоянным множитеелм мы принебрегаем( пользуясь 5-ым правилом).
        }
        return sum / i;// Это на самом деле 2 действия : подсчет сред. ариф. и return. Return'ом мы принебрегаем
                       // ( по анологии с 1-ым и 2-ым заданиями), а действием sum/i, пренебречь мы не можем. Поэтому сложность данного алгоритма равна : O(n+k)
    }




}
